---
import MenuItem from './MenuItem.astro';
import type { MenuData } from '../types/menu';

export interface Props {
  menuData: MenuData;
  showSearch?: boolean;
  className?: string;
}

const { menuData, showSearch = true, className = '' } = Astro.props;
---

<div class={`space-y-6 ${className}`} data-menu-display>
  <!-- Restaurant Info Header -->
  <header class="text-center bg-white rounded-lg shadow-sm border border-gray-200 p-6" role="banner">
    <h1 class="text-3xl font-bold text-gray-900 mb-2" id="restaurant-name">
      {menuData.restaurant.name}
    </h1>
    {menuData.restaurant.address && (
      <p class="text-gray-600 text-sm mb-2" aria-label="Restaurant address">
        {menuData.restaurant.address}
      </p>
    )}
  </header>

  <!-- Search Bar -->
  {showSearch && (
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4" role="search">
      <div class="relative">
        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </div>
        <input
          type="text"
          id="menu-search"
          class="block w-full pl-10 pr-3 py-3 border border-gray-300 rounded-lg leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
          placeholder="Search menu items..."
          aria-label="Search menu items"
          autocomplete="off"
        />
      </div>
      <div id="search-results-summary" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    </div>
  )}

  <!-- Loading State -->
  <div id="menu-loading" class="hidden text-center py-8" role="status" aria-live="polite">
    <div class="inline-flex items-center px-4 py-2 font-semibold leading-6 text-sm text-blue-600">
      <svg class="animate-spin -ml-1 mr-3 h-5 w-5" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Loading menu...
    </div>
  </div>

  <!-- Error State -->
  <div id="menu-error" class="hidden bg-red-50 border border-red-200 rounded-lg p-4" role="alert">
    <div class="flex items-center">
      <svg class="h-5 w-5 text-red-400 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      <p class="text-red-700 font-medium">Failed to load menu</p>
    </div>
    <p class="text-red-600 text-sm mt-1" id="error-message">Please try refreshing the page or contact the restaurant.</p>
  </div>

  <!-- Empty State -->
  <div id="menu-empty" class="hidden text-center py-12 bg-white rounded-lg shadow-sm border border-gray-200">
    <svg class="h-12 w-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
    </svg>
    <h3 class="text-lg font-medium text-gray-900 mb-2">No menu items found</h3>
    <p class="text-gray-500">The menu is not available at this time.</p>
  </div>

  <!-- No Search Results -->
  <div id="no-search-results" class="hidden text-center py-8 bg-white rounded-lg shadow-sm border border-gray-200">
    <svg class="h-10 w-10 text-gray-400 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
    </svg>
    <h3 class="text-md font-medium text-gray-900 mb-1">No results found</h3>
    <p class="text-gray-500 text-sm">Try adjusting your search terms.</p>
  </div>

  <!-- Menu Sections -->
  <div id="menu-sections" class="space-y-6">
    {menuData.sections && menuData.sections.length > 0 ? (
      menuData.sections.map((section, sectionIndex) => (
        <section 
          class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 menu-section" 
          data-section-id={section.id}
          role="region"
          aria-labelledby={`section-title-${section.id}`}
        >
          <h2 
            class="text-xl font-semibold text-gray-900 mb-4 section-title" 
            id={`section-title-${section.id}`}
          >
            {section.name}
          </h2>
          
          {section.items && section.items.length > 0 ? (
            <div class="space-y-4" role="list" aria-label={`${section.name} items`}>
              {section.items.map((item, itemIndex) => (
                <div role="listitem" class="menu-item-wrapper" data-item-name={item.name.toLowerCase()} data-item-description={item.description?.toLowerCase() || ''}>
                  <MenuItem 
                    id={item.id}
                    name={item.name}
                    description={item.description}
                    price={item.price}
                    sectionName={section.name}
                  />
                </div>
              ))}
            </div>
          ) : (
            <p class="text-gray-500 text-center py-4 italic">No items available in this section</p>
          )}
        </section>
      ))
    ) : null}
  </div>
</div>

<script>
  // Menu Display functionality
  class MenuDisplay {
    private searchInput: HTMLInputElement | null;
    private menuSections: NodeListOf<Element>;
    private menuItems: NodeListOf<Element>;
    private searchResultsSummary: HTMLElement | null;
    private noSearchResults: HTMLElement | null;
    private searchDebounceTimer: number = 0;

    constructor() {
      this.searchInput = document.getElementById('menu-search') as HTMLInputElement;
      this.menuSections = document.querySelectorAll('.menu-section');
      this.menuItems = document.querySelectorAll('.menu-item-wrapper');
      this.searchResultsSummary = document.getElementById('search-results-summary');
      this.noSearchResults = document.getElementById('no-search-results');
      
      this.initializeSearch();
      this.initializeKeyboardNavigation();
    }

    private initializeSearch(): void {
      if (!this.searchInput) return;

      this.searchInput.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        clearTimeout(this.searchDebounceTimer);
        
        this.searchDebounceTimer = window.setTimeout(() => {
          this.performSearch(target.value.toLowerCase().trim());
        }, 150);
      });

      // Clear search on escape
      this.searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          this.clearSearch();
        }
      });
    }

    private performSearch(query: string): void {
      if (!query) {
        this.clearSearch();
        return;
      }

      let visibleSections = 0;
      let totalVisibleItems = 0;

      this.menuSections.forEach(section => {
        const items = section.querySelectorAll('.menu-item-wrapper');
        let visibleItemsInSection = 0;

        items.forEach(item => {
          const name = item.getAttribute('data-item-name') || '';
          const description = item.getAttribute('data-item-description') || '';
          
          const matches = name.includes(query) || description.includes(query);
          
          if (matches) {
            (item as HTMLElement).style.display = '';
            visibleItemsInSection++;
            totalVisibleItems++;
            this.highlightSearchTerm(item, query);
          } else {
            (item as HTMLElement).style.display = 'none';
            this.clearHighlight(item);
          }
        });

        // Show/hide section based on whether it has visible items
        if (visibleItemsInSection > 0) {
          (section as HTMLElement).style.display = '';
          visibleSections++;
        } else {
          (section as HTMLElement).style.display = 'none';
        }
      });

      // Show/hide no results message
      if (this.noSearchResults) {
        this.noSearchResults.style.display = totalVisibleItems === 0 ? 'block' : 'none';
      }

      // Update screen reader summary
      this.updateSearchResultsSummary(totalVisibleItems, query);
    }

    private clearSearch(): void {
      if (this.searchInput) {
        this.searchInput.value = '';
      }

      // Show all sections and items
      this.menuSections.forEach(section => {
        (section as HTMLElement).style.display = '';
      });

      this.menuItems.forEach(item => {
        (item as HTMLElement).style.display = '';
        this.clearHighlight(item);
      });

      // Hide no results message
      if (this.noSearchResults) {
        this.noSearchResults.style.display = 'none';
      }

      // Clear search results summary
      if (this.searchResultsSummary) {
        this.searchResultsSummary.textContent = '';
      }
    }

    private highlightSearchTerm(item: Element, query: string): void {
      const nameElement = item.querySelector('h3');
      const descElement = item.querySelector('p');

      if (nameElement) {
        this.addHighlightToElement(nameElement, query);
      }
      if (descElement) {
        this.addHighlightToElement(descElement, query);
      }
    }

    private clearHighlight(item: Element): void {
      const nameElement = item.querySelector('h3');
      const descElement = item.querySelector('p');

      if (nameElement) {
        this.clearHighlightFromElement(nameElement);
      }
      if (descElement) {
        this.clearHighlightFromElement(descElement);
      }
    }

    private addHighlightToElement(element: Element, query: string): void {
      if (!query) return;
      
      const originalText = element.getAttribute('data-original-text') || element.textContent || '';
      if (!element.getAttribute('data-original-text')) {
        element.setAttribute('data-original-text', originalText);
      }
      
      // Clear existing content
      element.innerHTML = '';
      
      // Create safe highlighted content using DOM manipulation
      const regex = new RegExp(`(${this.escapeRegExp(query)})`, 'gi');
      const parts = originalText.split(regex);
      
      parts.forEach((part, index) => {
        if (part.toLowerCase() === query.toLowerCase()) {
          // Create highlight element for matching text
          const mark = document.createElement('mark');
          mark.className = 'bg-yellow-200 px-1 rounded';
          mark.textContent = part;
          element.appendChild(mark);
        } else {
          // Add plain text node for non-matching text
          const textNode = document.createTextNode(part);
          element.appendChild(textNode);
        }
      });
    }

    private clearHighlightFromElement(element: Element): void {
      const originalText = element.getAttribute('data-original-text');
      if (originalText) {
        element.textContent = originalText;
      }
    }

    private escapeRegExp(string: string): string {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    private updateSearchResultsSummary(count: number, query: string): void {
      if (!this.searchResultsSummary) return;

      if (count === 0) {
        this.searchResultsSummary.textContent = `No results found for "${query}"`;
      } else {
        this.searchResultsSummary.textContent = `Found ${count} item${count === 1 ? '' : 's'} matching "${query}"`;
      }
    }

    private initializeKeyboardNavigation(): void {
      // Add keyboard navigation for menu items
      const menuButtons = document.querySelectorAll('.menu-item-wrapper button');
      
      menuButtons.forEach((button, index) => {
        button.addEventListener('keydown', (e) => {
          const event = e as KeyboardEvent;
          
          switch (event.key) {
            case 'ArrowDown':
              e.preventDefault();
              this.focusNextButton(index, menuButtons);
              break;
            case 'ArrowUp':
              e.preventDefault();
              this.focusPrevButton(index, menuButtons);
              break;
            case 'Home':
              e.preventDefault();
              (menuButtons[0] as HTMLElement)?.focus();
              break;
            case 'End':
              e.preventDefault();
              (menuButtons[menuButtons.length - 1] as HTMLElement)?.focus();
              break;
          }
        });
      });
    }

    private focusNextButton(currentIndex: number, buttons: NodeListOf<Element>): void {
      const visibleButtons = Array.from(buttons).filter(btn => 
        (btn as HTMLElement).offsetParent !== null
      );
      const currentVisibleIndex = visibleButtons.indexOf(buttons[currentIndex]);
      const nextIndex = (currentVisibleIndex + 1) % visibleButtons.length;
      (visibleButtons[nextIndex] as HTMLElement).focus();
    }

    private focusPrevButton(currentIndex: number, buttons: NodeListOf<Element>): void {
      const visibleButtons = Array.from(buttons).filter(btn => 
        (btn as HTMLElement).offsetParent !== null
      );
      const currentVisibleIndex = visibleButtons.indexOf(buttons[currentIndex]);
      const prevIndex = currentVisibleIndex === 0 ? visibleButtons.length - 1 : currentVisibleIndex - 1;
      (visibleButtons[prevIndex] as HTMLElement).focus();
    }

    // Public method to handle loading state
    public showLoading(): void {
      const loading = document.getElementById('menu-loading');
      const sections = document.getElementById('menu-sections');
      const error = document.getElementById('menu-error');
      
      if (loading) loading.style.display = 'block';
      if (sections) sections.style.display = 'none';
      if (error) error.style.display = 'none';
    }

    // Public method to handle error state
    public showError(message?: string): void {
      const loading = document.getElementById('menu-loading');
      const sections = document.getElementById('menu-sections');
      const error = document.getElementById('menu-error');
      const errorMessage = document.getElementById('error-message');
      
      if (loading) loading.style.display = 'none';
      if (sections) sections.style.display = 'none';
      if (error) error.style.display = 'block';
      if (errorMessage && message) errorMessage.textContent = message;
    }

    // Public method to show menu content
    public showMenu(): void {
      const loading = document.getElementById('menu-loading');
      const sections = document.getElementById('menu-sections');
      const error = document.getElementById('menu-error');
      const empty = document.getElementById('menu-empty');
      
      if (loading) loading.style.display = 'none';
      if (error) error.style.display = 'none';
      
      // Check if menu has any sections
      const hasSections = this.menuSections.length > 0;
      
      if (hasSections) {
        if (sections) sections.style.display = 'block';
        if (empty) empty.style.display = 'none';
      } else {
        if (sections) sections.style.display = 'none';
        if (empty) empty.style.display = 'block';
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new MenuDisplay();
  });

  // Export for external use
  if (typeof window !== 'undefined') {
    (window as any).MenuDisplay = MenuDisplay;
  }
</script>

<style>
  /* Ensure proper focus styles for accessibility */
  .menu-item-wrapper button:focus {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }

  /* Search highlight styles */
  mark {
    background-color: #fef3c7;
    padding-left: 0.25rem;
    padding-right: 0.25rem;
    border-radius: 0.25rem;
  }

  /* Smooth transitions for show/hide */
  .menu-section,
  .menu-item-wrapper {
    transition: opacity 0.2s ease-in-out;
  }

  /* Loading spinner animation is handled by Tailwind's animate-spin */
</style>
